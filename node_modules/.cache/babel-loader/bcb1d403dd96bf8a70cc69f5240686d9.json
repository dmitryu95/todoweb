{"ast":null,"code":"module.exports = minimatch;\nminimatch.Minimatch = Minimatch;\n\nconst path = (() => {\n  try {\n    return require('path');\n  } catch (e) {}\n})() || {\n  sep: '/'\n};\n\nminimatch.sep = path.sep;\nconst GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};\n\nconst expand = require('brace-expansion');\n\nconst plTypes = {\n  '!': {\n    open: '(?:(?!(?:',\n    close: '))[^/]*?)'\n  },\n  '?': {\n    open: '(?:',\n    close: ')?'\n  },\n  '+': {\n    open: '(?:',\n    close: ')+'\n  },\n  '*': {\n    open: '(?:',\n    close: ')*'\n  },\n  '@': {\n    open: '(?:',\n    close: ')'\n  }\n}; // any single thing other than /\n// don't need to escape / when using new RegExp()\n\nconst qmark = '[^/]'; // * => any number of characters\n\nconst star = qmark + '*?'; // ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\n\nconst twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'; // not a ^ or / followed by a dot,\n// followed by anything, any number of times.\n\nconst twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'; // characters that need to be escaped in RegExp.\n\nconst reSpecials = charSet('().*{}+?[]^$\\\\!'); // \"abc\" -> { a:true, b:true, c:true }\n\nfunction charSet(s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true;\n    return set;\n  }, {});\n} // normalizes slashes.\n\n\nconst slashSplit = /\\/+/;\nminimatch.filter = filter;\n\nfunction filter(pattern, options) {\n  options = options || {};\n  return function (p, i, list) {\n    return minimatch(p, pattern, options);\n  };\n}\n\nfunction ext(a, b) {\n  a = a || {};\n  b = b || {};\n  const t = {};\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k];\n  });\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k];\n  });\n  return t;\n}\n\nminimatch.defaults = function (def) {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch;\n  }\n\n  const orig = minimatch;\n\n  const m = function minimatch(p, pattern, options) {\n    return orig(p, pattern, ext(def, options));\n  };\n\n  m.Minimatch = function Minimatch(pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options));\n  };\n\n  m.Minimatch.defaults = options => {\n    return orig.defaults(ext(def, options)).Minimatch;\n  };\n\n  m.filter = function filter(pattern, options) {\n    return orig.filter(pattern, ext(def, options));\n  };\n\n  m.defaults = function defaults(options) {\n    return orig.defaults(ext(def, options));\n  };\n\n  m.makeRe = function makeRe(pattern, options) {\n    return orig.makeRe(pattern, ext(def, options));\n  };\n\n  m.braceExpand = function braceExpand(pattern, options) {\n    return orig.braceExpand(pattern, ext(def, options));\n  };\n\n  m.match = function (list, pattern, options) {\n    return orig.match(list, pattern, ext(def, options));\n  };\n\n  return m;\n};\n\nMinimatch.defaults = function (def) {\n  return minimatch.defaults(def).Minimatch;\n};\n\nfunction minimatch(p, pattern, options) {\n  assertValidPattern(pattern);\n  if (!options) options = {}; // shortcut: comments match nothing.\n\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false;\n  } // \"\" only matches \"\"\n\n\n  if (pattern.trim() === '') return p === '';\n  return new Minimatch(pattern, options).match(p);\n}\n\nfunction Minimatch(pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options);\n  }\n\n  assertValidPattern(pattern);\n  if (!options) options = {};\n  pattern = pattern.trim(); // windows support: need to use /, not \\\n\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/');\n  }\n\n  this.options = options;\n  this.set = [];\n  this.pattern = pattern;\n  this.regexp = null;\n  this.negate = false;\n  this.comment = false;\n  this.empty = false; // make the set of regexps etc.\n\n  this.make();\n}\n\nMinimatch.prototype.debug = function () {};\n\nMinimatch.prototype.make = make;\n\nfunction make() {\n  // don't do it more than once.\n  if (this._made) return;\n  var pattern = this.pattern;\n  var options = this.options; // empty patterns and comments match nothing.\n\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true;\n    return;\n  }\n\n  if (!pattern) {\n    this.empty = true;\n    return;\n  } // step 1: figure out negation, etc.\n\n\n  this.parseNegate(); // step 2: expand braces\n\n  var set = this.globSet = this.braceExpand();\n  if (options.debug) this.debug = console.error;\n  this.debug(this.pattern, set); // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit);\n  });\n  this.debug(this.pattern, set); // glob --> regexps\n\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this);\n  }, this);\n  this.debug(this.pattern, set); // filter out everything that didn't compile properly.\n\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1;\n  });\n  this.debug(this.pattern, set);\n  this.set = set;\n}\n\nMinimatch.prototype.parseNegate = parseNegate;\n\nfunction parseNegate() {\n  var pattern = this.pattern;\n  var negate = false;\n  var options = this.options;\n  var negateOffset = 0;\n  if (options.nonegate) return;\n\n  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {\n    negate = !negate;\n    negateOffset++;\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset);\n  this.negate = negate;\n} // Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\n\n\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options);\n};\n\nMinimatch.prototype.braceExpand = braceExpand;\n\nfunction braceExpand(pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options;\n    } else {\n      options = {};\n    }\n  }\n\n  pattern = typeof pattern === 'undefined' ? this.pattern : pattern;\n  assertValidPattern(pattern);\n\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern];\n  }\n\n  return expand(pattern);\n}\n\nconst MAX_PATTERN_LENGTH = 1024 * 64;\n\nconst assertValidPattern = pattern => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern');\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long');\n  }\n}; // parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\n\nMinimatch.prototype.parse = parse;\nconst SUBPARSE = {};\n\nfunction parse(pattern, isSub) {\n  assertValidPattern(pattern);\n  var options = this.options; // shortcuts\n\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR;\n  if (pattern === '') return '';\n  var re = '';\n  var hasMagic = false;\n  var escaping = false; // ? => one single character\n\n  var patternListStack = [];\n  var negativeLists = [];\n  var stateChar;\n  var inClass = false;\n  var reClassStart = -1;\n  var classStart = -1; // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))' : '(?!\\\\.)';\n  var self = this;\n\n  function clearStateChar() {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star;\n          hasMagic = true;\n          break;\n\n        case '?':\n          re += qmark;\n          hasMagic = true;\n          break;\n\n        default:\n          re += '\\\\' + stateChar;\n          break;\n      }\n\n      self.debug('clearStateChar %j %j', stateChar, re);\n      stateChar = false;\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c); // skip over any that are escaped.\n\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c;\n      escaping = false;\n      continue;\n    }\n\n    switch (c) {\n      case '/':\n        /* istanbul ignore next */\n        {\n          // completely not allowed, even escaped.\n          // Should already be path-split by now.\n          return false;\n        }\n\n      case '\\\\':\n        clearStateChar();\n        escaping = true;\n        continue;\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c); // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n\n        if (inClass) {\n          this.debug('  in class');\n          if (c === '!' && i === classStart + 1) c = '^';\n          re += c;\n          continue;\n        } // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n\n\n        self.debug('call clearStateChar %j', stateChar);\n        clearStateChar();\n        stateChar = c; // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n\n        if (options.noext) clearStateChar();\n        continue;\n\n      case '(':\n        if (inClass) {\n          re += '(';\n          continue;\n        }\n\n        if (!stateChar) {\n          re += '\\\\(';\n          continue;\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        }); // negation is (?:(?!js)[^/]*)\n\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';\n        this.debug('plType %j %j', stateChar, re);\n        stateChar = false;\n        continue;\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)';\n          continue;\n        }\n\n        clearStateChar();\n        hasMagic = true;\n        var pl = patternListStack.pop(); // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n\n        re += pl.close;\n\n        if (pl.type === '!') {\n          negativeLists.push(pl);\n        }\n\n        pl.reEnd = re.length;\n        continue;\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|';\n          escaping = false;\n          continue;\n        }\n\n        clearStateChar();\n        re += '|';\n        continue;\n      // these are mostly the same in regexp and glob\n\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar();\n\n        if (inClass) {\n          re += '\\\\' + c;\n          continue;\n        }\n\n        inClass = true;\n        classStart = i;\n        reClassStart = re.length;\n        re += c;\n        continue;\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c;\n          escaping = false;\n          continue;\n        } // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n\n\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i);\n\n          try {\n            RegExp('[' + cs + ']');\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE);\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]';\n            hasMagic = hasMagic || sp[1];\n            inClass = false;\n            continue;\n          }\n        } // finish up the class.\n\n\n        hasMagic = true;\n        inClass = false;\n        re += c;\n        continue;\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar();\n\n        if (escaping) {\n          // no need\n          escaping = false;\n        } else if (reSpecials[c] && !(c === '^' && inClass)) {\n          re += '\\\\';\n        }\n\n        re += c;\n    } // switch\n\n  } // for\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n\n\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1);\n    sp = this.parse(cs, SUBPARSE);\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0];\n    hasMagic = hasMagic || sp[1];\n  } // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n\n\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length);\n    this.debug('setting tail', re, pl); // maybe some even number of \\, then maybe 1 \\, followed by a |\n\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\';\n      } // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n\n\n      return $1 + $1 + $2 + '|';\n    });\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re);\n    var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\\\' + pl.type;\n    hasMagic = true;\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail;\n  } // handle trailing things that only matter at the very end.\n\n\n  clearStateChar();\n\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\';\n  } // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n\n\n  var addPatternStart = false;\n\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(':\n      addPatternStart = true;\n  } // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n\n\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n];\n    var nlBefore = re.slice(0, nl.reStart);\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);\n    var nlAfter = re.slice(nl.reEnd);\n    nlLast += nlAfter; // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n\n    var openParensBefore = nlBefore.split('(').length - 1;\n    var cleanAfter = nlAfter;\n\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '');\n    }\n\n    nlAfter = cleanAfter;\n    var dollar = '';\n\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$';\n    }\n\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n    re = newRe;\n  } // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n\n\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re;\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re;\n  } // parsing just a piece of a larger pattern.\n\n\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic];\n  } // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n\n\n  if (!hasMagic) {\n    return globUnescape(pattern);\n  }\n\n  var flags = options.nocase ? 'i' : '';\n\n  try {\n    var regExp = new RegExp('^' + re + '$', flags);\n  } catch (er)\n  /* istanbul ignore next - should be impossible */\n  {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.');\n  }\n\n  regExp._glob = pattern;\n  regExp._src = re;\n  return regExp;\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe();\n};\n\nMinimatch.prototype.makeRe = makeRe;\n\nfunction makeRe() {\n  if (this.regexp || this.regexp === false) return this.regexp; // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n\n  var set = this.set;\n\n  if (!set.length) {\n    this.regexp = false;\n    return this.regexp;\n  }\n\n  var options = this.options;\n  var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n  var flags = options.nocase ? 'i' : '';\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;\n    }).join('\\\\\\/');\n  }).join('|'); // must match entire pattern\n  // ending in a * or ** will make it less strict.\n\n  re = '^(?:' + re + ')$'; // can match anything, as long as it's not this.\n\n  if (this.negate) re = '^(?!' + re + ').*$';\n\n  try {\n    this.regexp = new RegExp(re, flags);\n  } catch (ex)\n  /* istanbul ignore next - should be impossible */\n  {\n    this.regexp = false;\n  }\n\n  return this.regexp;\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {};\n  const mm = new Minimatch(pattern, options);\n  list = list.filter(function (f) {\n    return mm.match(f);\n  });\n\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern);\n  }\n\n  return list;\n};\n\nMinimatch.prototype.match = match;\n\nfunction match(f, partial) {\n  this.debug('match', f, this.pattern); // short-circuit in the case of busted things.\n  // comments, etc.\n\n  if (this.comment) return false;\n  if (this.empty) return f === '';\n  if (f === '/' && partial) return true;\n  var options = this.options; // windows: need to use /, not \\\n\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/');\n  } // treat the test path as a set of pathparts.\n\n\n  f = f.split(slashSplit);\n  this.debug(this.pattern, 'split', f); // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set;\n  this.debug(this.pattern, 'set', set); // Find the basename of the path by looking for the last non-empty segment\n\n  var filename;\n  var i;\n\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i];\n    if (filename) break;\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i];\n    var file = f;\n\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename];\n    }\n\n    var hit = this.matchOne(file, pattern, partial);\n\n    if (hit) {\n      if (options.flipNegate) return true;\n      return !this.negate;\n    }\n  } // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n\n\n  if (options.flipNegate) return false;\n  return this.negate;\n} // set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\n\n\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options;\n  this.debug('matchOne', {\n    'this': this,\n    file: file,\n    pattern: pattern\n  });\n  this.debug('matchOne', file.length, pattern.length);\n\n  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n    this.debug('matchOne loop');\n    var p = pattern[pi];\n    var f = file[fi];\n    this.debug(pattern, p, f); // should be impossible.\n    // some invalid regexp stuff in the set.\n\n    /* istanbul ignore if */\n\n    if (p === false) return false;\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f]); // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n\n      var fr = fi;\n      var pr = pi + 1;\n\n      if (pr === pl) {\n        this.debug('** at the end'); // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;\n        }\n\n        return true;\n      } // ok, let's see if we can swallow whatever we can.\n\n\n      while (fr < fl) {\n        var swallowee = file[fr];\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee); // XXX remove this slice.  Just pass the start index.\n\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee); // found a match.\n\n          return true;\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {\n            this.debug('dot detected!', file, fr, pattern, pr);\n            break;\n          } // ** swallows a segment, and continue.\n\n\n          this.debug('globstar swallow a segment, and continue');\n          fr++;\n        }\n      } // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n\n      /* istanbul ignore if */\n\n\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n        if (fr === fl) return true;\n      }\n\n      return false;\n    } // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n\n\n    var hit;\n\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase();\n      } else {\n        hit = f === p;\n      }\n\n      this.debug('string match', p, f, hit);\n    } else {\n      hit = f.match(p);\n      this.debug('pattern match', p, f, hit);\n    }\n\n    if (!hit) return false;\n  } // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n  // now either we fell off the end of the pattern, or we're done.\n\n\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true;\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial;\n  } else\n    /* istanbul ignore else */\n    if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === '';\n    } // should be unreachable.\n\n  /* istanbul ignore next */\n\n\n  throw new Error('wtf?');\n}; // replace stuff like \\* with *\n\n\nfunction globUnescape(s) {\n  return s.replace(/\\\\(.)/g, '$1');\n}\n\nfunction regExpEscape(s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n}","map":{"version":3,"sources":["/Users/dmitriyu/node_modules/minimatch/minimatch.js"],"names":["module","exports","minimatch","Minimatch","path","require","e","sep","GLOBSTAR","expand","plTypes","open","close","qmark","star","twoStarDot","twoStarNoDot","reSpecials","charSet","s","split","reduce","set","c","slashSplit","filter","pattern","options","p","i","list","ext","a","b","t","Object","keys","forEach","k","defaults","def","length","orig","m","makeRe","braceExpand","match","assertValidPattern","nocomment","charAt","trim","join","regexp","negate","comment","empty","make","prototype","debug","_made","parseNegate","globSet","console","error","globParts","map","si","parse","indexOf","negateOffset","nonegate","l","substr","nobrace","test","MAX_PATTERN_LENGTH","TypeError","SUBPARSE","isSub","noglobstar","re","hasMagic","escaping","patternListStack","negativeLists","stateChar","inClass","reClassStart","classStart","patternStart","dot","self","clearStateChar","len","noext","push","type","start","reStart","pl","pop","reEnd","cs","substring","RegExp","er","sp","tail","slice","replace","_","$1","$2","addPatternStart","n","nl","nlBefore","nlFirst","nlLast","nlAfter","openParensBefore","cleanAfter","dollar","newRe","globUnescape","flags","nocase","regExp","_glob","_src","twoStar","regExpEscape","ex","mm","f","nonull","partial","filename","file","matchBase","hit","matchOne","flipNegate","fi","pi","fl","fr","pr","swallowee","toLowerCase","Error"],"mappings":"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","sourcesContent":["module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nconst path = (() => { try { return require('path') } catch (e) {}})() || {\n  sep: '/'\n}\nminimatch.sep = path.sep\n\nconst GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nconst expand = require('brace-expansion')\n\nconst plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nconst reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nconst slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  const t = {}\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = function minimatch (p, pattern, options) {\n    return orig(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n  m.Minimatch.defaults = options => {\n    return orig.defaults(ext(def, options)).Minimatch\n  }\n\n  m.filter = function filter (pattern, options) {\n    return orig.filter(pattern, ext(def, options))\n  }\n\n  m.defaults = function defaults (options) {\n    return orig.defaults(ext(def, options))\n  }\n\n  m.makeRe = function makeRe (pattern, options) {\n    return orig.makeRe(pattern, ext(def, options))\n  }\n\n  m.braceExpand = function braceExpand (pattern, options) {\n    return orig.braceExpand(pattern, ext(def, options))\n  }\n\n  m.match = function (list, pattern, options) {\n    return orig.match(list, pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  assertValidPattern(pattern)\n\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\nconst MAX_PATTERN_LENGTH = 1024 * 64\nconst assertValidPattern = pattern => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nconst SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  assertValidPattern(pattern)\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = false\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/': /* istanbul ignore next */ {\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n      }\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) /* istanbul ignore next - should be impossible */ {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) /* istanbul ignore next - should be impossible */ {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    /* istanbul ignore if */\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      /* istanbul ignore if */\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else /* istanbul ignore else */ if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    return (fi === fl - 1) && (file[fi] === '')\n  }\n\n  // should be unreachable.\n  /* istanbul ignore next */\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n"]},"metadata":{},"sourceType":"script"}